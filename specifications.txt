1. Overview
There are two main parts of our library: our game framework: which is basically our structure for creating bodies and a game loop and setting the rules by which bodies interact with each other and the outside world, and our library code, which has classes we've written for handling collision detection and response, sprite animation and graphical effects, timers, and other structures that we think our users will likely need.

2. Framework
The basic paradigm on which our framework is structured is that the end user should be able to program by defining a set of rules, rather than writing in an imperative manner. Our code functions handles the main game loop and uses callbacks provided by the user to respond to specified events.

2.1 Being
The most basic unit of our framework is the Being, which is the representation of an object in the game. Being have their own draw method, which determines exactly how it is drawn to the screen, and coordinates. Obviously, user implementations of bodies will have many other parameters. The basic idea of beings, however, is that beings are "dumb", that is, they don't know much about one another or about the environment they exist in.

2.2 Group
Being are contained within Groups. A Group is pretty much just an alias for a Collection of Beings. One of the few things Beings do know is what groups they are contained in. This is needed for easy deletion when Beings need to be destroyed (for example, when characters die).

2.3.1 Environment
Beings are governed by Environments and Interactors. An Environment is a child of Group, and is used for updating beings. Updating an environment simply applies an update sequentially to all contained beings. For example, this can be used to apply a uniform downward force of gravity, or friction. Environments can be bounded spatially to filter the beings within them, for example a game level could have both air and water areas, with different laws of physics.

2.3.2 Interactor
Interactors govern relationships between beings. An interactor is a parametrized interface with two methods: detect and handle. Detect simply determines if two being should interact, and handle applies the results of the interaction. This can be applied to a wide variety of situations. For example, it could be used for a general force calculation as in Galaxy, or for collision detection and response, or for something more specific like character X steps on pad Y, causing door Z to open. Interactors will be the main way to set conditional rules for the game.

2.3.3 Optimizer

To speed up interaction handling, we have an interface called Optimizer, which prevents O(n^2) interaction checking. The Optimizer performs some operation that sorts Beings in such a way that their interaction can be checked in an optimized manner, for example building a quadtree or sorting Beings by the room or board area they occupy. This structure is used to detect many interactions at a time, preventing inefficient calculations.

2.4 World
The whole game state is governed by the World class. The World keeps track of all of the beings and runs the main loop, checking for and handling interactions. World has a registerInteraction method that allows the user to register groups of interacting beings for checking. The order in which they register will determine the order of checking. Once they have set up all their interactions and environment, they can simply call World.run() and we will handle all of the updating for them. Or they can choose to override our updating method and handle the loop themself. World.draw(), which is called by the main drawing loop, uses a Camera object to determine which objects need to be drawn, sorts them by their z coordinate, and then calls their draw method after translating their world coordinates into screen coordinates.

2.5 God
All of this happens (literally) under God. God is basically a singleton object that sets whichever world the game is currently playing in, handles transitions between worlds, and deals with global drawing effects. World updating runs on its own thread (separate from the graphics thread).


2.6 Post Office
The PostOffice is a way to abstract controls and messaging. It will be used for communication to and from external controls (think: keyboard, gamepads, midi devices, other games, etc etc). It uses a publish/subscribe pattern, and generalizes messages such that beings and in game events will not know about the things controlling them. 

3. Library Code

3.1 Collision Suite
A shape based system that provides robust collision information. User should be able to find out if two shapes are colliding, on what sides, and degree of containment. Will support collisions across different shapes (point, line, rectangle, triangle, ellipse, and most likely arbitrary as well)

3.2 Sprite 
Our Sprite class is a helper for wrapping Processing's PImages. It is based on tile-maps, and has utilities to parse tiles based on information provided by the user at construction. The user will be able to run animated sprites, and the framerate can be locked regardless of varying levels of computational activity. The user will also be able to have safe access to the image data such that they can do pixel level effects. 

3.2 Collider
This extension of Interactor implements a shape-based collision detection system using the collision suite, and is probably the collision system that most users will use most of the time.

3.2 ForceBeing and MassedCollider
This extension of Being and Collider respectively provides for a basic, pre-built physics engine. A ForceBeing has vectors for position, velocity, and force, as well as a mass variable. MassedCollider handles collisions between objects based on shape and mass. The user can set collision elasticity -- the percent of energy absorbed in the collision.

3.4 Vector Field Environment
This environment implementation will control the motion of objects based on a user-defined vector field

3.5 Graphics Effects
We will provide implementations for a number of pixel-level graphical effects such as fades and wipes.

3.6 Tile-based world implementation
We will provide a specific implementation of world and being classes optimized for a tile-based game environment in which the coordinate system is quantized.

4. How it works on the user end

We want our library to be as extensible and as applicable to as many situations as possible. However, we think that the main user workflow will be somthing like this:

-- define the coordinate systema and create a class hierarchy of beings for all the game objects
-- define one or more environments to handle your basic physics rules
-- define the interactions. This would probably start with basic things like general collision response and then venture into the specifcs.
-- define messages and handling for external input 
-- define all levels and screens using worlds (for complicated games this would probably necessitate using files)
-- define the Processing set-up and draw methods. draw() must call God.draw().

But, of course, the user has the option of overriding all of our framework code (or ingnoring it), and just using us for collision detection, messaging, graphics, etc.

=====================================================================================

Demo 1: Curtains

Is a generative environment borrowing game mechanics from the "bullet-hell" aka "shoot-em-up genre." 
It takes the trope of games like R-Type and creates a "codebendable" environment for play and exploration. 
The user will send and receiver information over OSC addresses to interact with the environment.

The user will send messages to the following OSC addresses: 
	/SetPlayerShipX
	/SetPlayerShipY
		move a player ship on an x and y axis (continuous value between 0.0 and 1.0)
	/ShootBullet
		shoot a bullet from the player ship (trigger value of 1.0)
	/GenerateEnemy
		generate enemy ships (trigger value of 1.0)
	/SetEnemySpawnX
	/SetEnemySpawnY
		specify the x and y coordinate of where new enemy ships are generated
	/SetEnemySpeed
		set how fast enemy ships travel 
	/ChangeEnemyStyle
		ability to step through a set of graphics, determining how new enemy ships will be drawn (trigger value of 1.0)
	/ChangeBackgroundStyle
		ability to step through a minimal set of background graphics / colors (trigger value of 1.0)

Via the post office, the player will receiver the following information over OSC addresses:

	/OldestEnemyX
	/OldestEnemyY
		oldest enemy ship x and y 
	/NewestEnemyX
	/NewestEnemyY
		newest enemy ship x and y
	/PlayerShipCollided
		notification of player ship collision (trigger value of 1.0)
	/EnemyShipDestroyed
		notification of destruction of an enemy ship (trigger value of 1.0)

=====================================================================================
